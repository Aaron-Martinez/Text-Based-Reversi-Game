import java.util.Random;
import java.util.Scanner;

/**
 * This class represents a computer player of the reversi game that makes smart moves based on an algorithm.
 * 
 * @author Aaron Martinez    <ajm21935@uga.edu>
 * @author Matt Butcher    <mab48671@uga.edu>
 *
 */
public class IntelligentComputerPlayer extends ComputerPlayer {

	private ReversiBoard board; //An instance of reversiBoard that this intelligentComputerPlayer is playing on
	
	private int[][] values = {{100, -20, 10,  5,  5, 10, -20, 100},
							  {-20, -50, -2, -2, -2, -2, -50, -20},		// The value of each square that the computer
							  { 10,  -2, -1, -1, -1, -1,  -2,  10},		// player will base move choices on
							  {  5,  -2, -1, -1, -1, -1,  -2,   5},
							  {  5,  -2, -1, -1, -1, -1,  -2,   5},
							  { 10,  -2, -1, -1, -1, -1,  -2,  10},
							  {-20, -50, -2, -2, -2, -2, -50, -20},
							  {100, -20, 10,  5,  5, 10, -20, 100}};
	
	private char[][] tempGrid; 	//A temporary 2D char array of the game board that the computer player can test moves on
	
	/**
	 * Constructs an instance of IntelligentComputerPlayer and assigns it to a ReversiBoard object that is specified
	 * in the parameter. This method assigns the board instance variable to the game parameter and initializes the
	 * 2D char array tempGrid.
	 * 
	 * @param game
	 * 			An instance of ReversiBoard that stores the game being played by this player
	 */
    public IntelligentComputerPlayer(ReversiBoard game) {
    	board = game;
    	tempGrid = new char[8][8];
    }

    /**
     * This method returns a string that represents the move the IntelligentComputerPlayer has chosen in
     * "[row] [column]" format. The actual move choice is made by calling the smartChoice() method in move
     * 
     * @return smartChoice()
     * 				Returns a string that is generated by the smartChoice method.
     */
    public String move() {
    	
    	if(board.getRounds() == 26) {
    		for(int m = 0; m < 8; m++) {
    		    for(int n = 0; n < 8; n++) {
    		    	values[m][n] += 5;		    		
    		    }//for
    		}//for
    	}//if
    	
    	if(board.getRounds() == 30) {
    		for(int m = 0; m < 8; m++) {
    		    for(int n = 0; n < 8; n++) {
    		    	values[m][n] += 10;		    		
    		    }//for
    		}//for
    	}//if
    	
    	return(smartChoice());
    }//move()
    
    /**
     * Creates an array that stores all legal moves in string format, and tests each of these moves using
     * the calculatePointValue() command. The best move is chosen and returned in string format.
     * 
     * @return move
     * 			A string that represents the move the IntelligentComputerPlayer has chosen in
     * 			"[row] [column]" format.
     */
    public String smartChoice() {

    	delay();
    	String move = "";
    	int numMoves = 0;
    	int count = 0;
    	int bestValue = -10000;
    	
    	for(int m = 0; m < 8; m++) {
		    for(int n = 0; n < 8; n++) {
		    	if(board.getGridDisplay()[m][n] == '_') {
		    		numMoves++;		    		
		    	}		    		
		    }  
    	}//for
    	
    	String[] choices = new String[numMoves];
    	
    	for(int m = 0; m < 8; m++) {
		    for(int n = 0; n < 8; n++) {
		    	if(board.getGridDisplay()[m][n] == '_') {
		    		choices[count] = "" + (m + 1) + " " + (n + 1);
		    		count++;
		    	}//if		    		
		    }//for
    	}//for
    	
    	for(int m = 0; m < choices.length; m++) {
    		
    		int value = calculatePointValue(choices[m]);
    		if(value > bestValue) {
    			bestValue = value;
    			move = choices[m];
    		}//if
    	}//for   	
    	return move;
    }//smartChoice()
    
    /**
     * 
     * @param s
     * 			The move being tested in string format "[row] [column]"
     * @return pointValue
     * 			The point value given to this move using the values instance variable.
     */
    public int calculatePointValue(String s) {
    	int pointValue = 0;
    
    	for(int i = 0; i < 8; i++) {
    		for(int j = 0; j < 8; j++) {
    			tempGrid[i][j] = board.getGridDisplay()[i][j];
    		}
    	}
    	
    	test(s);
    	
    	for(int m = 0; m < 8; m++) {
		    for(int n = 0; n < 8; n++) {
		    	if(tempGrid[m][n] == myPiece) {
		    		pointValue += values[m][n];
		    	}
		    }
    	}
    	return pointValue;
    }

    /**
     * This method first resets tempGrid to be the same as the current reversiBoard grid, and then tests the move
     * that is passed in as a parameter by flipping the squares in the temporary grid, which are later given a point
     * value in the calculatePointValue() method.
     * 
     * @param s
     * 			The move being tested in string format "[row] [column]"
     */
	public void test(String s) {
	    	
	    	Scanner move = new Scanner(s);
	    	int row = move.nextInt() - 1;
	    	int col = move.nextInt() - 1;
	    
	    	for(int i = 0; i < 8; i++) {
	    		for(int j = 0; j < 8; j++) {
	    	
	    			tempGrid[i][j] = board.getGridDisplay()[i][j];
	    		}
	    	}
	    	
	    	boolean right = testRight(row, col);
	    	boolean left = testLeft(row, col);
	    	boolean up = testUp(row, col);
	    	boolean down = testDown(row, col);
	    	boolean upRight = testUpRight(row, col);
	    	boolean upLeft = testUpLeft(row, col);
	    	boolean downRight = testDownRight(row, col);
	    	boolean downLeft = testDownLeft(row, col);
	    	
	    	if(right) {
	    		for(int i = row, j = col + 1; tempGrid[i][j] != myPiece; j++) {
	    			tempGrid[i][j] = myPiece;
	    		}
	    	}
	    		
	    	if(left) {
	    		for(int i = row, j = col - 1; tempGrid[i][j] != myPiece; j--) {
	    			tempGrid[i][j] = myPiece;
	    		}
	    	}
	    		
	    	if(up) {
	    		for(int i = row - 1, j = col; tempGrid[i][j] != myPiece; i--) {
	    			tempGrid[i][j] = myPiece;
	    		}
	    	}
	    		
	    	if(down) {
	    		for(int i = row + 1, j = col; tempGrid[i][j] != myPiece; i++) {
	    			tempGrid[i][j] = myPiece;
	    		}
	    	}
	    		
			if(upLeft) {
				for(int i = row - 1, j = col - 1; tempGrid[i][j] != myPiece; i--, j--) {
	    			tempGrid[i][j] = myPiece;
	    		}
			}
				
			if(downLeft) {
				for(int i = row + 1, j = col - 1; tempGrid[i][j] != myPiece; i++, j--) {
	    			tempGrid[i][j] = myPiece;
	    		}
			}
				
			if(downRight) {
				for(int i = row + 1, j = col + 1; tempGrid[i][j] != myPiece; i++, j++) {
	    			tempGrid[i][j] = myPiece;
	    		}
			}
	    	
			if(upRight) {
				for(int i = row - 1, j = col + 1; tempGrid[i][j] != myPiece; i--, j++) {
	    			tempGrid[i][j] = myPiece;
	    		}
			}
			
			tempGrid[row][col] = myPiece;
	    	
	    }//flip()
    
	/**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * right direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
	public boolean testRight(int row, int col) {
	    
	    	if (col>5)
	    		return false;
	    	
	    	if(tempGrid[row][col+1]== opponentsPiece){	
				for(int m=col+2; m<=7; m++){
					if(tempGrid[row][m] == '.' || tempGrid[row][m] == '_') return false;
					if(tempGrid[row][m] == myPiece ) return true;
					if(tempGrid[row][m] == opponentsPiece ) continue;
				}
	    	}
	    	return false;
	    }//testRight
    
	/**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * left direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
    public boolean testLeft(int row, int col){
    	if (col<2)
    		return false;
    	
    	if(tempGrid[row][col-1]==opponentsPiece){
			for(int m=col-2; m>=0; m--){
				if(tempGrid[row][m] == '.' || tempGrid[row][m] == '_') return false;
				if(tempGrid[row][m] == myPiece ) return true;
				if(tempGrid[row][m] == opponentsPiece ) continue;
			}
    	}
    	
    	return false;
    }
    
    /**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * up direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
    public boolean testUp(int row, int col){
    	if (row<2)
    		return false;
    	
    	if(tempGrid[row-1][col]==opponentsPiece){
			for(int m=row-2; m>=0; m--){
				if(tempGrid[m][col] == '.' || tempGrid[m][col] == '_') return false;
				if(tempGrid[m][col] == myPiece ) return true;
				if(tempGrid[m][col] == opponentsPiece ) continue;
			}
    	}
    	
    	return false;
    }
    
    /**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * down direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
    public boolean testDown(int row, int col){
    	if (row>5)
    		return false;
    	
    	if(tempGrid[row+1][col]==opponentsPiece){
			for(int m=row+2; m<=7; m++){
				if(tempGrid[m][col] == '.' || tempGrid[m][col] == '_') return false;
				if(tempGrid[m][col] == myPiece ) return true;
				if(tempGrid[m][col] == opponentsPiece ) continue;
			}
    	}
    	
    	return false;
    }
    
    /**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * left direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
	public boolean testUpLeft(int row, int col){
    	if (row<2 || col<2)
    		return false;
    	
    	if(tempGrid[row-1][col-1]==opponentsPiece){
    		for(int m = row - 2, n = col - 2; m >=0 && n>= 0; m--, n--) {
			
					if(tempGrid[m][n] == '.' || tempGrid[m][n] == '_') return false;
					if(tempGrid[m][n] == myPiece ) return true;
					if(tempGrid[m][n] == opponentsPiece ) continue;
			}
    	}
    	return false;
	}	
	
	/**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * down-left direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
	public boolean testDownLeft(int row, int col){
    	if (row>5 || col<2)
    		return false;
    	
    	if(tempGrid[row+1][col-1]==opponentsPiece){
    		
    		for(int m = row + 2, n = col - 2; m <= 7 && n >= 0; m++, n--) {
					if(tempGrid[m][n] == '.' || tempGrid[m][n] == '_') return false;
					if(tempGrid[m][n] == myPiece ) return true;
					if(tempGrid[m][n] == opponentsPiece ) continue;
			}
    	}
    	return false;
	}
	
	/**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * down-right direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
	public boolean testDownRight(int row, int col){
    	if (row>5 || col>5)
    		return false;
    	
    	if(tempGrid[row+1][col+1]==opponentsPiece){
    		for(int m = row + 2, n = col + 2; m <= 7 && n <= 7; m++, n++) {
					if(tempGrid[m][n] == '.' || tempGrid[m][n] == '_') return false;
					if(tempGrid[m][n] == myPiece ) return true;
					if(tempGrid[m][n] == opponentsPiece ) continue;
			}
    	}
    	return false;
	}
	
	/**
     * This method checks whether or not placing a piece at the given spot sandwiches opponents pieces in the 
     * up-right direction in tempGrid.
     * 
     * @param row
     * 				The row index of the move chosen
     * @param col
     * 				The col index of the move chosen
     * @return true or false
     * 				Returns true if this move sandwiches opponents pieces in the down direction. False otherwise
     */
	public boolean testUpRight(int row, int col){
    	if (row<2 || col>5)
    		return false;
    	
    	if(tempGrid[row-1][col+1]==opponentsPiece){
    		for(int m = row - 2, n = col + 2; m >=0 && n <= 7; m--, n++) {
					if(tempGrid[m][n] == '.' || tempGrid[m][n] == '_') return false;
					if(tempGrid[m][n] == myPiece ) return true;
					if(tempGrid[m][n] == opponentsPiece ) continue;
			}
    	}
    	return false;
    	
	}//testUpRight()
	
}//IntelligentComputerPlayer